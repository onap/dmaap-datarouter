/*******************************************************************************
 * ============LICENSE_START==================================================
 * * org.onap.dmaap
 * * ===========================================================================
 * * Copyright Â© 2017 AT&T Intellectual Property. All rights reserved.
 * * ===========================================================================
 * * Licensed under the Apache License, Version 2.0 (the "License");
 * * you may not use this file except in compliance with the License.
 * * You may obtain a copy of the License at
 * *
 *  *      http://www.apache.org/licenses/LICENSE-2.0
 * *
 *  * Unless required by applicable law or agreed to in writing, software
 * * distributed under the License is distributed on an "AS IS" BASIS,
 * * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * * See the License for the specific language governing permissions and
 * * limitations under the License.
 * * ============LICENSE_END====================================================
 * *
 * * ECOMP is a trademark and service mark of AT&T Intellectual Property.
 * *
 ******************************************************************************/


package org.onap.dmaap.datarouter.provisioning;

import com.att.eelf.configuration.EELFLogger;
import com.att.eelf.configuration.EELFManager;
import java.io.IOException;
import java.util.*;
import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.lang3.StringUtils;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.json.JSONTokener;
import org.onap.dmaap.datarouter.provisioning.beans.EventLogRecord;
import org.onap.dmaap.datarouter.provisioning.beans.IngressRoute;
import org.onap.dmaap.datarouter.provisioning.eelf.EelfMsgs;
import org.onap.dmaap.datarouter.provisioning.utils.DB;
import org.slf4j.MDC;

/**
 * This servlet handles redirects for the &lt;publishURL&gt; on the provisioning server, which is generated by the
 * provisioning server to handle a particular subscriptions to a feed. See the <b>File Publishing and Delivery API</b>
 * document for details on how these methods should be invoked.
 *
 * @author Robert Eby
 * @version $Id: PublishServlet.java,v 1.8 2014/03/12 19:45:41 eby Exp $
 */
@SuppressWarnings("serial")
public class PublishServlet extends BaseServlet {

    private int nextNode;
    private String provstring;
    private List<IngressRoute> irt;
    //Adding EELF Logger Rally:US664892
    private static EELFLogger eelflogger = EELFManager.getInstance()
            .getLogger("org.onap.dmaap.datarouter.provisioning.PublishServlet");
    private static final Object lock = new Object();


    @Override
    public void init(ServletConfig config) throws ServletException {
        super.init(config);
        nextNode = 0;
        provstring = "";
        irt = new ArrayList<>();

    }

    @Override
    public void doDelete(HttpServletRequest req, HttpServletResponse resp) throws ServletException {
        setUpEelfForPublishServlet(req, "doDelete");
        eelflogger.info(EelfMsgs.ENTRY);
        try {
            eelflogger.info(EelfMsgs.MESSAGE_WITH_BEHALF_AND_FEEDID, req.getHeader(BEHALF_HEADER), getIdFromPath(req) + "");
            redirect(req, resp);
        } finally {
            eelflogger.info(EelfMsgs.EXIT);
        }
    }

    @Override
    public void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException {
        setUpEelfForPublishServlet(req, "doGet");
        eelflogger.info(EelfMsgs.ENTRY);
        try {
        eelflogger.info(EelfMsgs.MESSAGE_WITH_BEHALF_AND_FEEDID, req.getHeader(BEHALF_HEADER), getIdFromPath(req) + "");
        redirect(req, resp);
        } finally {
            eelflogger.info(EelfMsgs.EXIT);
        }
    }

    @Override
    public void doPut(HttpServletRequest req, HttpServletResponse resp) throws ServletException {
        setUpEelfForPublishServlet(req, "doPut");
        eelflogger.info(EelfMsgs.ENTRY);
        try {
        eelflogger.info(EelfMsgs.MESSAGE_WITH_BEHALF_AND_FEEDID, req.getHeader(BEHALF_HEADER), getIdFromPath(req) + "");
        redirect(req, resp);
        } finally {
            eelflogger.info(EelfMsgs.EXIT);
        }
    }

    @Override
    public void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException {
        setUpEelfForPublishServlet(req, "doPost");
        eelflogger.info(EelfMsgs.ENTRY);
        try {
        eelflogger.info(EelfMsgs.MESSAGE_WITH_BEHALF, req.getHeader(BEHALF_HEADER));
        redirect(req, resp);
        } finally {
            eelflogger.info(EelfMsgs.EXIT);
        }

    }

    private void setUpEelfForPublishServlet(HttpServletRequest req, String method) {
        if (StringUtils.isBlank(req.getHeader("X-ONAP-RequestID")) || StringUtils.isBlank(req.getHeader("X-InvocationID"))) {
            setIpFqdnForEelf(method);
        } else {
            setIpFqdnRequestIDandInvocationIDForEelf(method, req);
        }
    }

    private void redirect(HttpServletRequest req, HttpServletResponse resp) throws ServletException {
        try {
            String[] nodes = getNodes();
            if (nodes == null || nodes.length == 0) {
                resp.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,
                        "There are no nodes defined in the DR network.");
            } else {
                EventLogRecord elr = new EventLogRecord(req);
                int feedid = checkPath(req);
                if (feedid < 0) {
                    String message = (feedid == -1)
                            ? "Invalid request - Missing or bad feed number."
                            : "Invalid request - Missing file ID.";
                    elr.setMessage(message);
                    elr.setResult(HttpServletResponse.SC_NOT_FOUND);
                    eventlogger.info(elr);

                    resp.sendError(HttpServletResponse.SC_NOT_FOUND, message);
                } else {
                    // Generate new URL
                    String nextnode = getRedirectNode(feedid, req);
                    nextnode = nextnode + ":" + DB.getHttpsPort();
                    String newurl = "https://" + nextnode + "/publish" + req.getPathInfo();
                    String qs = req.getQueryString();
                    if (qs != null) {
                        newurl += "?" + qs;
                    }

                    // Log redirect in event log
                    String message = "Redirected to: " + newurl;
                    elr.setMessage(message);
                    elr.setResult(HttpServletResponse.SC_MOVED_PERMANENTLY);
                    eventlogger.info(elr);

                    resp.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY);
                    resp.setHeader("Location", newurl);
                }
            }
        } catch (IOException ioe) {
            intlogger.error("IOException" + ioe.getMessage());

        }
    }

    private String getRedirectNode(int feedid, HttpServletRequest req) {
        // Check to see if the IRT needs to be updated
        Poker p = Poker.getPoker();
        String s = p.getProvisioningString();
        synchronized (lock) {
            if (irt == null || (s.length() != provstring.length()) || !s.equals(provstring)) {
                // Provisioning string has changed -- update the IRT
                provstring = s;
                JSONObject jo = new JSONObject(new JSONTokener(provstring));
                JSONArray ja = jo.getJSONArray("ingress");
                List<IngressRoute> newlist = new ArrayList<>();
                for (int i = 0; i < ja.length(); i++) {
                    IngressRoute iroute = new IngressRoute(ja.getJSONObject(i));
                    newlist.add(iroute);
                }
                irt = newlist;
            }
        }

        // Look in IRT for next node
        for (IngressRoute route : irt) {
            if (route.matches(feedid, req)) {
                // pick a node at random from the list
                Collection<String> nodes = route.getNodes();
                String[] arr = nodes.toArray(new String[0]);
                long id = System.currentTimeMillis() % arr.length;
                String node = arr[(int) id];
                intlogger.info("Redirecting to " + node + " because of route " + route);
                return node;
            }
        }

        // No IRT rule matches, do round robin of all active nodes
        String[] nodes = getNodes();
        if (nextNode >= nodes.length)    // The list of nodes may have grown/shrunk
        {
            nextNode = 0;
        }
        return nodes[nextNode++];
    }

    private int checkPath(HttpServletRequest req) {
        String path = req.getPathInfo();
        if (path == null || path.length() < 2) {
            return -1;
        }
        path = path.substring(1);
        int ix = path.indexOf('/');
        if (ix < 0 || ix == path.length() - 1) {
            return -2;
        }
        try {
            int feedid = Integer.parseInt(path.substring(0, ix));
            String provData = Poker.getPoker().getProvisioningString();
            JSONArray feeds = new JSONObject(provData).getJSONArray("feeds");
            for (int n = 0; n < feeds.length(); ++n) {
                if (feeds.getJSONObject(n).getInt("feedid") == feedid) {
                    return feedid;
                }
            }
            return -1;
        } catch (NumberFormatException | JSONException e) {
            return -1;
        }
    }
}
